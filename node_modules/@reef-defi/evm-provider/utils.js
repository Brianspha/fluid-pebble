"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dataToString = exports.toBN = exports.handleTxResponse = exports.decodeMessage = exports.U64MAX = exports.U32MAX = void 0;
/* eslint-disable prefer-promise-reject-errors */
const bignumber_1 = require("@ethersproject/bignumber");
const util_1 = require("@polkadot/util");
const bn_js_1 = __importDefault(require("bn.js"));
exports.U32MAX = bignumber_1.BigNumber.from('0xffffffff');
exports.U64MAX = bignumber_1.BigNumber.from('0xffffffffffffffff');
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function decodeMessage(reason, code) {
    const reasonString = JSON.stringify(reason).toLowerCase();
    let codeString = `0x${code.substr(138)}`.replace(/0+$/, '');
    // If the codeString is an odd number of characters, add a trailing 0
    if (codeString.length % 2 === 1) {
        codeString += '0';
    }
    return `${reasonString} ${(0, util_1.hexToString)(codeString)}`;
}
exports.decodeMessage = decodeMessage;
function handleTxResponse(result, api) {
    return new Promise((resolve, reject) => {
        if (result.status.isFinalized || result.status.isInBlock) {
            const createdFailed = result.findRecord('evm', 'CreatedFailed');
            const executedFailed = result.findRecord('evm', 'ExecutedFailed');
            result.events
                .filter(({ event: { section } }) => section === 'system')
                .forEach((event) => {
                const { event: { data, method } } = event;
                if (method === 'ExtrinsicFailed') {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const [dispatchError] = data;
                    let message = dispatchError.type;
                    if (dispatchError.isModule) {
                        try {
                            const mod = dispatchError.asModule;
                            const error = api.registry.findMetaError(new Uint8Array([mod.index.toNumber(), mod.error.toNumber()]));
                            message = `${error.section}.${error.name}`;
                        }
                        catch (error) {
                            // swallow
                        }
                    }
                    reject({ message, result });
                }
                else if (method === 'ExtrinsicSuccess') {
                    const failed = createdFailed || executedFailed;
                    if (failed) {
                        reject({
                            message: decodeMessage(failed.event.data[1].toJSON(), failed.event.data[2].toJSON()),
                            result
                        });
                    }
                    resolve({ result });
                }
            });
        }
        else if (result.isError) {
            reject({ result });
        }
    });
}
exports.handleTxResponse = handleTxResponse;
function toBN(bigNumberis = 0) {
    if ((0, util_1.isU8a)(bigNumberis)) {
        return (0, util_1.u8aToBn)(bigNumberis);
    }
    if ((0, util_1.isHex)(bigNumberis)) {
        return (0, util_1.hexToBn)(bigNumberis);
    }
    if (bignumber_1.BigNumber.isBigNumber(bigNumberis)) {
        const hex = bigNumberis.toHexString();
        if (hex[0] === '-') {
            return new bn_js_1.default('-' + hex.substring(3), 16);
        }
        return new bn_js_1.default(hex.substring(2), 16);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new bn_js_1.default(bigNumberis);
}
exports.toBN = toBN;
function dataToString(bytes) {
    if ((0, util_1.isBuffer)(bytes)) {
        return (0, util_1.u8aToHex)((0, util_1.bufferToU8a)(bytes));
    }
    if ((0, util_1.isU8a)(bytes)) {
        return (0, util_1.u8aToHex)(bytes);
    }
    if (Array.isArray(bytes)) {
        return (0, util_1.u8aToHex)(Buffer.from(bytes));
    }
    return bytes;
}
exports.dataToString = dataToString;
//# sourceMappingURL=utils.js.map